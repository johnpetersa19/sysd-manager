#!/usr/bin/env python3
import build_aux.build_common as bc
from  build_aux.build_common import color
import os
import re
import argparse
import xml.etree.ElementTree as ET


AUR_DIR="../aur/sysd-manager"
PKGBUILD="PKGBUILD"
INSTALL_FILE="sysd-manager.install" 
AUR_OUT_DIR="../aur/sysd-manager"
TEMPLATE_DIR='packaging/aur'

def main():
    os.chdir("..")

    parser = argparse.ArgumentParser(
        description="Aur builder",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )

    parser.add_argument(
        "action",
        choices=[
            "sum",
            "pkfile",
            "gen",
            "clean",
            "make",
            "log",
            "genpush"
        ],
        help="action to perform",)

    args = parser.parse_args()

    match args.action:
        case "generate":
            gen_pkfile()
        case "sum":
            do_check_sum()
        case "pkfile":
            create_pkgbuild()
        case "clean":
            clean()
        case "make":
            make()
        case "genpush":
            generate_and_push()

        case "log":
            change_log()

def create_pkgbuild():
    #version
    version = bc.get_version()
    print(f"Version {color.BOLD}{color.CYAN}{version}{color.END}")

    #set commit tag
    tag_name = bc.get_version_tag()
    print(f"Tag name {color.BOLD}{color.CYAN}{tag_name}{color.END}")


    commit = bc.get_tag_commit(tag_name)

    print(f"Commit {color.BOLD}{color.CYAN}{commit}{color.END}")


    pkgbuild_text = ""

    with open(f'{TEMPLATE_DIR}/{PKGBUILD}', "r") as pkgbuild_file:
        pkgbuild_text = pkgbuild_file.read()

    #set the version
    pkgbuild_text = pkgbuild_text.replace("pkgver=\n", f"pkgver={version}\n")

    #put the commit label
    pkgbuild_text = pkgbuild_text.replace("_commit=\n", f"_commit={commit}\n")


    with open(f'{AUR_OUT_DIR}/{PKGBUILD}', "w") as pkgbuild_file:
        pkgbuild_file.write(pkgbuild_text)        
    
    
    #print(pkgbuild_text)
    #sums

    bc.cmd_run(["cp", f"{TEMPLATE_DIR}/{INSTALL_FILE}", f"{AUR_OUT_DIR}"])


def do_check_sum():
    cmd = ["makepkg", "-g"]  
    checksum = bc.cmd_run_str(cmd, cwd=f"{AUR_OUT_DIR}")

    print("OUT: ", checksum)

    pkgbuild_text = ""

    with open(f'{AUR_OUT_DIR}/{PKGBUILD}', "r") as pkgbuild_file:
        print("WRITE SUM on ")
        pkgbuild_text = pkgbuild_file.read()
        #set the version
    
    pkgbuild_text = pkgbuild_text.replace("sha256sums=()\n", checksum)

    with open(f'{AUR_OUT_DIR}/{PKGBUILD}', "w") as pkgbuild_file:
        print("WRITE SUM ")

        pkgbuild_file.write(pkgbuild_text)       


def generate_sourceinfo():
    cmd = ["makepkg", "--printsrcinfo"]  
    printsrcinfo = bc.cmd_run_str(cmd, cwd=f"{AUR_OUT_DIR}")

    with open(f'{AUR_OUT_DIR}/.SRCINFO', "w") as srcinfo_file:
        print("WRITE .SRCINFO")
        srcinfo_file.write(printsrcinfo)     


def gen_pkfile(): 
    create_pkgbuild()
    do_check_sum()
    generate_sourceinfo()


def generate_and_push(): 
    gen_pkfile()

    push()

def push():
    tag_name = bc.get_version_tag()

    print(f"Commit {color.BOLD}{color.CYAN}{tag_name}{color.END}")

    bc.cmd_run(["git", "commit", "-a", "-m", f"'{tag_name}'"], cwd=f"{AUR_OUT_DIR}")

    print(f"{color.BOLD}{color.CYAN}Push on AUR{color.END}")

    bc.cmd_run(["git", "push"], cwd=f"{AUR_OUT_DIR}")


def make(): 
    gen_pkfile()

    bc.cmd_run(["makepkg"], cwd=f"{AUR_OUT_DIR}")

def clean():
    list_dir = [
        "PKGBUILD",
        "src",
        "sysd-manager",
        "pkg",
        "*.zst",
        ".SRCINFO",
        f"{INSTALL_FILE}",
    ]

    for f in list_dir:
        print(f"{color.BOLD}Deleting{color.END} {color.YELLOW}{f}{color.END}")
        #x = " ".join(["rm", "-fr", f])
        bc.cmd_run(["rm", "-fr", f], cwd=f"{AUR_OUT_DIR}", shell=True)

def change_log():
    #https://keepachangelog.com/en/1.1.0/
    tree = ET.parse('./data/metainfo/io.github.plrigaux.sysd-manager.metainfo.xml')
    root = tree.getroot()
    
    
    out = """# Changelog
All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.1.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

"""
    change_type = set(['Added', 'Changed', 'Deprecated', 'Removed' ,'Fixed' ,'Security'])

    for release in root.iter('release'):
        version = release.get('version')
        date = release.get('date')
        
        out += f"## [{version}] - {date}\n\n"
        
        for description in release.iter('description'):
            for sub in description.iter('*'):
                if sub.tag == "p":
                    if sub.text in change_type:
                        out += f"### {sub.text}\n\n"
                    else:
                        out += sub.text + "\n\n"
                    
                if sub.tag == "li":
                   out += "- " + sub.text + "\n"
            
            out += "\n"
    
    print (out)        
    
    with open("CHANGELOG.md", "w") as f:
        f.write(out)


main()